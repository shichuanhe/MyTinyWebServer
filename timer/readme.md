**定时器的目的:**
    a.为了让他去处理非活动连接。因为我们的系统资源是有限的，当一个客户连接长时间不响应时，我们就要考虑关闭这个连接，把资源分给正在使用的客户，以此来提高服务器的运行效率。
    b.定时剔除掉长时间不动的空闲用户，避免他们占着茅坑不拉屎，耗费服务器资源
    c.一般的做法是**将每个定时事件封装成定时器，并使用某种容器类数据结构将所有的定时器保存好**，实现对定时事件的统一管理。常用方法有排序链表、红黑树、时间堆和时间轮。这里使用的是升序双向链表

——————————————————————————————————————————————
时间堆：lst_timer 代码实现了一个基于小根堆的定时器，主要用于管理 TCP 连接超时事件。

1.底层： 
    a.client_data 结构体：存储客户端信息（地址、socket、绑定的定时器）。
    b.util_timer 类：表示单个定时器，存储超时时间、回调函数等。
    c.time_heap 类：使用小根堆（std::vector）管理多个 util_timer，支持增删查操作。
    d.Utils 工具类：封装信号处理、Epoll 文件描述符管理等辅助功能。
2.原理：
    将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔，当超时时间到达时，处理超时事件，然后再次从剩余定时器中找出超时时间最小的一个，依次反复即可。为了后面处理过期连接的方便，我们给每一个定时器里面放置一个回调函数，用来关闭过期连接.
    栗子：
        当前系统时间：8:00 , 1号定时器超时时间：8:05 , 2号定时器超时时间：8:08
        设置心搏间隔：8:05-8:00=5
        5分钟到达后处理1号定时器事件，再根据2号超时时间设定心搏间隔.

    定时器基于小根堆（std::vector<util_timer*>）实现，其中：
        堆顶元素（最小值）始终是即将超时的定时器。
        heapify_up（上浮）： 当插入新定时器时，确保堆结构不被破坏。
        heapify_down（下沉）： 删除定时器后，调整堆结构，保持最小堆特性。

3.函数
    a.tick():
        遍历时间堆，从头开始依次处理每个定时器，直到遇到尚未到期的定时器
        若当前时间小于定时器超时时间，跳出循环，即未找到到期的定时器
        若当前时间大于定时器超时时间，即找到了到期的定时器，执行回调函数，然后将它从链表中删除，然后继续遍历

    b.heapify_up(int index),heapify_down(int index):
        调整小根堆，维持结构->堆排序
        ·插入新元素：新元素默认插入到堆的末尾，然后需要 上浮（heapify_up） 来维持堆的性质。
        ·删除堆顶元素（最小值）：删除堆顶后，最后一个元素填补堆顶位置，然后需要 下沉（heapify_down） 以恢复堆的性质。
        
        (1)堆排序原理：
            完全二叉树，堆通常用数组存储，每个节点 i 的子节点和父节点可以通过以下公式计算：
                左子节点：left = 2 * i + 1
                右子节点：right = 2 * i + 2
                父节点：parent = (i - 1) / 2
            参考博客：https://blog.csdn.net/m0_46132054/article/details/113749310

        (2)heapify_up:
            当插入一个新元素后，该元素位于堆的最后一个位置 index，如果它比其父节点的 expire 值更小，就需要不断地与父节点交换位置，直到它满足最小堆的性质。
        (3)heapify_down：
            当删除堆顶元素后，最后一个元素会填充到堆顶，此时可能会破坏堆的性质，需要将该元素向下调整，以恢复最小堆。

————————————————————————————————————————————————————————————
utils 工具类
服务器首先创建定时器容器链表，然后用统一事件源将异常事件，读写事件和信号事件统一处理，根据不同事件的对应逻辑使用定时器。
    1.每过一段时间就给主循环一个信号，主循环收到信号就记录下来，等其他IO事件完成之后，就调用tick()处理非活动连接。具体的：
        a.浏览器与服务器连接时，创建该连接对应的定时器，并将该定时器添加到链表上
        b.处理异常事件时，执行定时事件，服务器关闭连接，从链表上移除对应定时器
        c.处理定时信号时，将定时标志设置为true
        d.处理读事件时，若某连接上发生读事件，将对应定时器向后移动，否则，执行定时事件
        e.处理写事件时，若服务器通过某连接给浏览器发送数据，将对应定时器向后移动，否则，执行定时事件
    2.非活动连接处理流程:
        a.主线程初始化Utils(包括使用pipe接收pipefd，用epollfd接收u_epollfd)
        b.主线程调用addfd将pipe管道与epollfd相关联
        c.主线程调用addsig将目标信号(SIGALRM SIGTERM)加入监听的信号集
        d.主线程循环eventLoop()开始，服务器开始运行
        e.多个客户连接长久未响应
        f.经过TIMESLOT， 触发信号，主循环收到信号
        g.主循环调用tick()处理非活动连接

    3.代码运行流程：
        服务器启动
        socket() 绑定端口
        listen() 监听
        epoll_create() 创建 epollfd

        init(m_TIMESLOT) 初始化定时器间隔
        pipe(u_pipefd) 创建 pipefd[0] 监听信号
        addfd(epollfd, pipefd[0], false, 0) 让 epoll 监听 pipefd[0]
        addsig(SIGALRM, sig_handler, false) 绑定定时信号
        alarm(m_TIMESLOT) 启动定时器
        
        eventLoop() 事件循环

        epoll_wait() 监听  ->返回事件集合
        
        处理事件，遍历epollpd中的事件
        监听 socket 连接 和 pipefd[0] 信号
        recv() 处理数据
        read(pipefd[0]) 读取信号并调用 timer_handler()
        定时任务

        tick() 关闭 超时连接
        alarm(m_TIMESLOT) 重新设定定时器
