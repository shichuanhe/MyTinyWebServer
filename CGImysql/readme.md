1.RAII:（Resource Acquisition Is Initialization）利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。    **核心思想：将资源与对象的生命周期绑定。避免资源泄漏。**
2.池：通常指的是一种资源管理的模式，其中资源被集中管理并通过预先分配而不是按需创建。减少资源创建、调度、销毁的开销。实现池的方法：数组，链表，队列等。


**懒汉+链表**实现数据库连接池 
1.数据库的资源我们使用信号量进行同步，所以，将**信号量初始化为数据库的连接总数**；
2.当用户需要使用数据库时，我们使用**信号量的wait()函数**，如果信号量的值大于0，那么可以使用数据库连接，信号量的值减1；
3.如果信号量的值等于0，那么就不能使用数据库连接，需要等待其他线程释放数据库连接，信号量的值加1；



**数据库连接池初始化**：首先使用mysql_init初始化一个MYSQL对象。然后使用mysql_real_connect尝试与数据库服务器建立实际连接。

1.MYSQL *mysql_init(MYSQL *mysql)：初始化一个MYSQL对象，为使用MySQL服务器准备一个连接句柄。
    参数：
        mysql: 可以是NULL或一个现有的MYSQL结构体指针。
    返回值：
        成功时返回MYSQL*指针。
        如果内存分配失败，返回NULL。
    作用：
        分配或初始化一个MYSQL对象，用于后续的连接操作。
        如果传入NULL，函数会分配、初始化并返回一个新的对象。
        如果传入一个已存在的对象，它会被重新初始化。

2.MYSQL *mysql_real_connect(MYSQL *mysql, 
                          const char *host,
                          const char *user,
                          const char *passwd,
                          const char *db,
                          unsigned int port,
                          const char *unix_socket,
                          unsigned long client_flag);

    功能：建立一个到MySQL数据库服务器的连接。
    主要参数：
        mysql: 由mysql_init()返回的MYSQL*句柄。
        host: 主机名或IP地址。
        user: MySQL账户用户名。
        passwd: 账户密码。
        db: 要使用的数据库名。
        port: 连接端口号（通常是3306）。
        unix_socket: Unix套接字（通常设为NULL）。
        client_flag: 连接选项。
    返回值：
        成功时返回MYSQL*连接句柄。
        失败时返回NULL。
    作用：
        尝试与MySQL服务器建立实际的网络连接。
        设置连接的各种参数，如用户认证、选择数据库等。  


**数据库访问函数**
值得注意的是，销毁连接池没有直接被外部调用，而是通过RAII机制来完成自动释放；使用信号量实现多线程争夺连接的同步机制，这里将信号量初始化为数据库的连接总数。
1.数据库连接函数：
    1.1 首先使用信号量的wait()函数，如果信号量的值大于0，那么可以使用数据库连接，信号量的值减1；
    1.2 如果信号量的值等于0，那么就不能使用数据库连接，需要等待其他线程释放数据库连接，信号量的值加1；
2.数据库释放函数：
    2.1 首先使用信号量的wait()函数，如果信号量的值大于0，那么可以使用数据库连接，信号量的值减1；
    2.2 如果信号量的值等于0，那么就不能使用数据库连接，需要等待其他线程释放数据库连接，信号量的值加1；
3.数据库销毁函数
    关闭连接池的所有连接，删除连接池的所有连接。

**RAII类**
这个类的唯一作用就是与数据库连接池的资源进行绑定；可以看到这个类中只有构造函数和析构函数。
这样当类创建实例时就会调用构造函数，构造函数内就会调用数据库连接函数；当类的生命周期结束时就会调用析构函数，析构函数会调用销毁数据库函数；从而实现了资源的获取与释放与类的实例的生命周期绑定。