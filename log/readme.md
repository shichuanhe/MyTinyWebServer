同步/异步日志系统
===============
同步/异步日志系统主要涉及了两个模块，一个是日志模块，一个是阻塞队列模块,其中加入阻塞队列模块主要是解决异步写入日志做准备.
> * 自定义阻塞队列
> * 单例模式创建日志
> * 同步日志
> * 异步日志
> * 实现按天、超行分类


LOG类就是项目的日志系统。所谓日志，即由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。

日志的实现有两种，一种是同步日志，一种是异步日志；

同步日志：日志写入函数与工作线程**串行**执行，由于涉及I/O操作，同步日志会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在访问峰值时，写日志可能会成为系统的瓶颈

异步日志：将工作线程所写的日志内容先存入**阻塞队列**，写线程从阻塞队列中取出内容，写入日志

单例模式：最简单也是被问到最多的设计模式之一，保证一个类只创建一个实例，同时提供全局访问的方法。
————————————————————————————————————————————————————————————————————————————————————————————————————
在异步日志中，每个工作线程当有日志需要处理时，将所需写的内容所在内存加入一个阻塞队列，然后就不管了。而日志系统会单独分配一个写线程，不断地从阻塞队列中获得任务并写入日志文件中。

从上面地日志工作流程描述中我们可以发现，这是一个典型的生产者-消费者模型。其中工作线程时生产，写线程是消费者。

那么，生产者-消费者模型的临界区(缓冲区)是什么呢？->环形缓冲区    在我们日志系统中，这个临界区就是一个队列。 在本项目中，我们使用**循环数组**来实现。

·异步写入方式，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。


class block_queue{
    block_queue(int max_size=1000);//初始化
    ~block_queue();//析构  删除*m_array
    
    bool full();//判断是否满队列
    bool empty();//判断是否为空

    bool front(T &value); //返回队首元素
    bool back(T &value);//返回队尾元素

    int size();//返回队列现有元素个数
    int max_size();//返回队列最大容量

    //往队列添加元素，需要将所有使用队列的线程先唤醒
    //当有元素push进队列,相当于生产者生产了一个元素
    //若当前没有线程等待条件变量,则唤醒无意义
    bool push(const T &item);
    
    //消费者
    bool pop(T &item);//pop时候，如果队列没有元素，将会等待条件变量
    bool pop(T &item,int ms_timeout);//超时处理
};

