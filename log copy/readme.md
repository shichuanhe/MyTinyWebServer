同步/异步日志系统
===============
同步/异步日志系统主要涉及了两个模块，一个是日志模块，一个是阻塞队列模块,其中加入阻塞队列模块主要是解决异步写入日志做准备.
> * 自定义阻塞队列
> * 单例模式创建日志
> * 同步日志
> * 异步日志
> * 实现按天、超行分类


LOG类就是项目的日志系统。所谓日志，即由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。

日志的实现有两种，一种是同步日志，一种是异步日志；

同步日志：日志写入函数与工作线程**串行**执行，由于涉及I/O操作，同步日志会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在访问峰值时，写日志可能会成为系统的瓶颈

异步日志：将工作线程所写的日志内容先存入**阻塞队列**，写线程从阻塞队列中取出内容，写入日志


·阻塞队列：
————————————————————————————————————————————————————————————————————————————————————————————————————
在异步日志中，每个工作线程当有日志需要处理时，将所需写的内容所在内存加入一个阻塞队列，然后就不管了。而日志系统会单独分配一个写线程，不断地从阻塞队列中获得任务并写入日志文件中。

从上面地日志工作流程描述中我们可以发现，这是一个典型的生产者-消费者模型。其中工作线程时生产，写线程是消费者。

那么，生产者-消费者模型的临界区(缓冲区)是什么呢？->环形缓冲区    在我们日志系统中，这个临界区就是一个队列。 在本项目中，我们使用**循环数组**来实现。

·异步写入方式，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。


class block_queue{
    block_queue(int max_size=1000);//初始化
    
    ~block_queue();//析构  删除*m_array
    void clear();//清空队列 ->元素不用删 覆盖就行
    
    bool full();//判断是否满队列
    bool empty();//判断是否为空

    bool front(T &value); //返回队首元素
    bool back(T &value);//返回队尾元素

    int size();//返回队列现有元素个数
    int max_size();//返回队列最大容量

    //往队列添加元素，需要将所有使用队列的线程先唤醒
    //当有元素push进队列,相当于生产者生产了一个元素
    //若当前没有线程等待条件变量,则唤醒无意义
    bool push(const T &item);
    
    //消费者
    bool pop(T &item);//pop时候，如果队列没有元素，将会等待条件变量
    bool pop(T &item,int ms_timeout);//超时处理
};

________________________________________________________

·单例模式：最简单也是被问到最多的设计模式之一，保证一个类只创建一个实例，同时提供全局访问的方法。
实现方式：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。


int snprintf(char *str, size_t size, const char *format, ...):用于格式化字符串并将结果写入缓冲区
参数说明：
    a.str：目标缓冲区，用于存储格式化后的字符串。
    b.size：缓冲区的大小，限制了可以写入的最大字符数（包括结尾的空字符）。
    c.format：格式化字符串，类似于 printf 中使用的格式。
    d....：可变参数列表，根据格式化字符串提供的相应参数。
返回值：格式化后的字符串的总长度

vsnprintf(m_buf + n, m_log_buf_size - n - 1, format, valst):
    a.它会按照 format 指定的格式，将 valst 中的参数格式化为字符串。
    b.格式化后的字符串会被写入到 m_buf + n 开始的位置。
    c.它最多写入 m_log_buf_size - n - 1 个字符，确保不会溢出缓冲区。